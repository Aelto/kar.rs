
// TODO: .repeat(), Either(). getAllFlagged().
// Use the string generated by the translate method

class Element {
  constructor(name) {
    this.name = name

    this.isOption = false

    this.translateFunction = null

    this.flagName = null
  }

  compare(element) {
    return this.isOption || this.name === element.type
  }

  option(bool = false) {
    this.isOption = bool

    return this
  }

  translate(fn = null) {
    this.translateFunction = fn

    return this
  }

  flag(name = null) {
    this.flagName = name

    return this
  }
}

class Container extends Element {
  constructor(name, children = []) {
    super(name)

    this.children = children
  }

  compare(ast, actionOnCompareTrue = null) {
    // console.log(`comparing ${ast.name} & ${this.name}`)
    if (!ast.group
     || !ast.group.length
     && ast.group.length !== this.children.length) {
      return false
    }

    if (this.name !== ast.name) {
      return false
    }

    let this_index = 0
    let ast_index = 0

    while (true) {
      const this_child = this.children[this_index]
      const cont_child = ast.group[ast_index]

      if (!cont_child && !this_child) {
        break
      }

      // console.log(`- comparing ${this_child.name} & ${cont_child.name || cont_child.type}`)

      if (!this_child && cont_child) {
        break
      }

      // no more items in the incoming ast,
      // while this ast expected some more
      if (!cont_child && !this_child.isOption) {
        return false
      }

      // this ast's child compare function returned
      // false, which means the two asts do not match
      const comparison = this_child.compare(cont_child)
      if (!comparison) {
        return false
      }

      if (actionOnCompareTrue !== null) {
        actionOnCompareTrue.bind(this)(this_child, cont_child)
        // this_child.run(cont_child)
      }

      this_index += 1
      ast_index += 1
    }

    return true
  }

  run(ast) {
    const comparison = this.compare(ast, (this_child, cont_child) => {
      if (this_child.run) this_child.run(cont_child)
    })

    if (comparison && this.translateFunction !== null) {
      this.translateFunction(this, ast)
    }
  }

  getFirstFlagged(ast, flag) {
    let out = null

    const comparison = this.compare(ast, (this_child, cont_child) => {
      if (this_child.flagName === flag) {
        return out = { grammar: this_child, ast: cont_child }
      }

      if (this_child.getFirstFlagged) {
        out = this_child.getFirstFlagged(cont_child, flag)
      }
    })

    return out
  }
}

const grammar = new Container('program', [
  new Container('variable', [
    new Element('let'),
    new Element('identifier').flag('var-name'),
    new Element('equal'),
    new Element('number').flag('var-value'),
    new Element('semicolon'),
  ]).translate((container, ast) => {
    const varName = container.getFirstFlagged(ast, 'var-name')
    const varValue = container.getFirstFlagged(ast, 'var-value')

    if (varName !== null && varValue !== null) {
      console.log(`auto ${varName.ast.value} = ${varValue.ast.value}`)
    }
  }),
])

const run = (ast, depth = 1) => {
  console.log(`${' '.repeat(depth)}${ast.name || ast.type}`)
  if (ast.group && ast.group.length) {
    for (const child of ast.group) {
      run(child, depth + 1)
    }
  }
}

module.exports = (AST) => {
  console.log(run(AST))
  grammar.run(AST)

}